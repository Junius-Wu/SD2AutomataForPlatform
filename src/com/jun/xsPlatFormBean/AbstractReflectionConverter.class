package com.thoughtworks.xstream.converters.reflection;

import com.thoughtworks.xstream.converters.ConversionException;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.SingleValueConverter;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.core.Caching;
import com.thoughtworks.xstream.core.ReferencingMarshallingContext;
import com.thoughtworks.xstream.core.util.ArrayIterator;
import com.thoughtworks.xstream.core.util.FastField;
import com.thoughtworks.xstream.core.util.HierarchicalStreams;
import com.thoughtworks.xstream.core.util.Primitives;
import com.thoughtworks.xstream.core.util.SerializationMembers;
import com.thoughtworks.xstream.io.ExtendedHierarchicalStreamWriterHelper;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.mapper.CannotResolveClassException;
import com.thoughtworks.xstream.mapper.Mapper;
import com.thoughtworks.xstream.mapper.Mapper.ImplicitCollectionMapping;
import com.thoughtworks.xstream.mapper.Mapper.Null;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public abstract class AbstractReflectionConverter
  implements Converter, Caching
{
  protected final ReflectionProvider reflectionProvider;
  protected final Mapper mapper;

  /** @deprecated */
  protected transient SerializationMethodInvoker serializationMethodInvoker;
  protected transient SerializationMembers serializationMembers;
  private transient ReflectionProvider pureJavaReflectionProvider;

  public AbstractReflectionConverter(Mapper mapper, ReflectionProvider reflectionProvider)
  {
    this.mapper = mapper;
    this.reflectionProvider = reflectionProvider;
    this.serializationMethodInvoker = new SerializationMethodInvoker();
    this.serializationMembers = this.serializationMethodInvoker.serializationMembers;
  }

  protected boolean canAccess(Class type) {
    try {
      this.reflectionProvider.getFieldOrNull(type, "%");
      return true;
    }
    catch (NoClassDefFoundError e) {
    }
    return false;
  }

  public void marshal(Object original, HierarchicalStreamWriter writer, MarshallingContext context)
  {
    Object source = this.serializationMembers.callWriteReplace(original);

    if ((source != original) && ((context instanceof ReferencingMarshallingContext))) {
      ((ReferencingMarshallingContext)context).replace(original, source);
    }
    if (source.getClass() != original.getClass()) {
      String attributeName = this.mapper.aliasForSystemAttribute("resolves-to");
      if (attributeName != null) {
        writer.addAttribute(attributeName, this.mapper.serializedClass(source.getClass()));
      }
      context.convertAnother(source);
    } else {
      doMarshal(source, writer, context);
    }
  }

  protected void doMarshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context)
  {
    final List fields = new ArrayList();
    final Map defaultFieldDefinition = new HashMap();

    this.reflectionProvider.visitSerializableFields(source, new ReflectionProvider.Visitor() {
      final Set writtenAttributes = new HashSet();

      public void visit(String fieldName, Class type, Class definedIn, Object value) {
        if (!AbstractReflectionConverter.this.mapper.shouldSerializeMember(definedIn, fieldName)) {
          return;
        }
        if (!defaultFieldDefinition.containsKey(fieldName)) {
          Class lookupType = source.getClass();

          if ((definedIn != source.getClass()) && 
            (!AbstractReflectionConverter.this.mapper
            .shouldSerializeMember(lookupType, fieldName)))
          {
            lookupType = definedIn;
          }
          defaultFieldDefinition.put(fieldName, AbstractReflectionConverter.this.reflectionProvider
            .getField(lookupType, fieldName));
        }

        SingleValueConverter converter = AbstractReflectionConverter.this.mapper.getConverterFromItemType(fieldName, type, definedIn);

        if (converter != null) {
          String attribute = AbstractReflectionConverter.this.mapper.aliasForAttribute(AbstractReflectionConverter.this.mapper.serializedMember(definedIn, fieldName));

          if (value != null) {
            if (this.writtenAttributes.contains(fieldName))
            {
              throw new ConversionException("Cannot write field with name '" + fieldName + "' twice as attribute for object of type " + source
                .getClass().getName());
            }
            String str = converter.toString(value);
            if (str != null) {
              writer.addAttribute(attribute, str);
            }
          }
          this.writtenAttributes.add(fieldName);
        } else {
          fields.add(new AbstractReflectionConverter.FieldInfo(fieldName, type, definedIn, value));
        }
      }
    });
    new Object()
    {
      void writeField(String fieldName, String aliasName, Class fieldType, Class definedIn, Object newObj)
      {
        Class actualType = newObj != null ? newObj.getClass() : fieldType;
        ExtendedHierarchicalStreamWriterHelper.startNode(writer, aliasName != null ? aliasName : AbstractReflectionConverter.this.mapper
          .serializedMember(source
          .getClass(), fieldName), actualType);

        if (newObj != null) {
          Class defaultType = AbstractReflectionConverter.this.mapper.defaultImplementationOf(fieldType);
          if (!actualType.equals(defaultType)) {
            String serializedClassName = AbstractReflectionConverter.this.mapper.serializedClass(actualType);
            if (!serializedClassName.equals(AbstractReflectionConverter.this.mapper.serializedClass(defaultType))) {
              String attributeName = AbstractReflectionConverter.this.mapper.aliasForSystemAttribute("class");
              if (attributeName != null) {
                writer.addAttribute(attributeName, serializedClassName);
              }
            }
          }

          Field defaultField = (Field)defaultFieldDefinition.get(fieldName);
          if (defaultField.getDeclaringClass() != definedIn) {
            String attributeName = AbstractReflectionConverter.this.mapper.aliasForSystemAttribute("defined-in");
            if (attributeName != null) {
              writer.addAttribute(attributeName, AbstractReflectionConverter.this.mapper
                .serializedClass(definedIn));
            }

          }

          Field field = AbstractReflectionConverter.this.reflectionProvider.getField(definedIn, fieldName);
          AbstractReflectionConverter.this.marshallField(context, newObj, field);
        }
        writer.endNode();
      }

      void writeItem(Object item, MarshallingContext context, HierarchicalStreamWriter writer)
      {
        if (item == null) {
          String name = AbstractReflectionConverter.this.mapper.serializedClass(null);
          ExtendedHierarchicalStreamWriterHelper.startNode(writer, name, Mapper.Null.class);

          writer.endNode();
        } else {
          String name = AbstractReflectionConverter.this.mapper.serializedClass(item.getClass());
          ExtendedHierarchicalStreamWriterHelper.startNode(writer, name, item
            .getClass());
          context.convertAnother(item);
          writer.endNode();
        }
      }
    };
  }

  protected void marshallField(MarshallingContext context, Object newObj, Field field) {
    context.convertAnother(newObj, this.mapper
      .getLocalConverter(field
      .getDeclaringClass(), field.getName()));
  }

  public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context)
  {
    Object result = instantiateNewInstance(reader, context);
    result = doUnmarshal(result, reader, context);
    return this.serializationMembers.callReadResolve(result);
  }

  public Object doUnmarshal(Object result, HierarchicalStreamReader reader, UnmarshallingContext context)
  {
    Class resultType = result.getClass();
    Set seenFields = new HashSet() {
      public boolean add(Object e) {
//        if (!super.add(e)) {
//          throw new AbstractReflectionConverter.DuplicateFieldException(((FastField)e).getName());
//        }
        return true;
      }
    };
    Iterator it = reader.getAttributeNames();
    while (it.hasNext()) {
      String attrAlias = (String)it.next();

      String attrName = this.mapper
        .realMember(resultType, this.mapper
        .attributeForAlias(attrAlias));

      Field field = this.reflectionProvider.getFieldOrNull(resultType, attrName);
      if ((field != null) && (shouldUnmarshalField(field))) {
        Class classDefiningField = field.getDeclaringClass();
        if (this.mapper.shouldSerializeMember(classDefiningField, attrName))
        {
          SingleValueConverter converter = this.mapper.getConverterFromAttribute(classDefiningField, attrName, field
            .getType());
          Class type = field.getType();
          if (converter != null) {
            Object value = converter.fromString(reader.getAttribute(attrAlias));
            if (type.isPrimitive()) {
              type = Primitives.box(type);
            }
            if ((value != null) && (!type.isAssignableFrom(value.getClass())))
            {
              throw new ConversionException("Cannot convert type " + value
                .getClass().getName() + " to type " + type
                .getName());
            }
            seenFields.add(new FastField(classDefiningField, attrName));
            this.reflectionProvider.writeField(result, attrName, value, classDefiningField);
          }
        }
      }
    }
    Map implicitCollectionsForCurrentObject = null;
    while (reader.hasMoreChildren()) {
      reader.moveDown();

      String originalNodeName = reader.getNodeName();
      Class explicitDeclaringClass = readDeclaringClass(reader);
      Class fieldDeclaringClass = explicitDeclaringClass == null ? resultType : explicitDeclaringClass;

      String fieldName = this.mapper.realMember(fieldDeclaringClass, originalNodeName);

      Mapper.ImplicitCollectionMapping implicitCollectionMapping = this.mapper
        .getImplicitCollectionDefForFieldName(fieldDeclaringClass, fieldName);

      String implicitFieldName = null;
      Field field = null;
      Class type = null;
      Object value;
      Object value;
      if (implicitCollectionMapping == null)
      {
        field = this.reflectionProvider.getFieldOrNull(fieldDeclaringClass, fieldName);
        Object value;
        if (field == null)
        {
          Class itemType = this.mapper.getItemTypeForItemFieldName(resultType, fieldName);
          if (itemType != null) {
            String classAttribute = HierarchicalStreams.readClassAttribute(reader, this.mapper);

            if (classAttribute != null)
              type = this.mapper.realClass(classAttribute);
            else
              type = itemType;
          }
          else
          {
            try
            {
              type = this.mapper.realClass(originalNodeName);
              implicitFieldName = this.mapper.getFieldNameForItemTypeAndName(context
                .getRequiredType(), type, originalNodeName);
            }
            catch (CannotResolveClassException e) {
            }
            if ((type == null) || ((type != null) && (implicitFieldName == null)))
            {
              handleUnknownField(explicitDeclaringClass, fieldName, resultType, originalNodeName);

              type = null;
            }
          }
          Object value;
          if (type == null)
          {
            value = null;
          }
          else
          {
            Object value;
            if (Map.Entry.class.equals(type))
            {
              reader.moveDown();
              Object key = context.convertAnother(result, 
                HierarchicalStreams.readClassType(reader, this.mapper));

              reader.moveUp();
              reader.moveDown();
              Object v = context.convertAnother(result, 
                HierarchicalStreams.readClassType(reader, this.mapper));

              reader.moveUp();

              value = Collections.singletonMap(key, v)
                .entrySet().iterator().next();
            }
            else {
              value = context.convertAnother(result, type);
            }
          }
        } else {
          boolean fieldAlreadyChecked = false;

          if (explicitDeclaringClass == null) {
            while (field != null)
            {
              if ((fieldAlreadyChecked = (shouldUnmarshalField(field)) && 
                (this.mapper
                .shouldSerializeMember(field
                .getDeclaringClass(), fieldName)) ? 1 : 0) != 0)
                break;
              field = this.reflectionProvider.getFieldOrNull(field
                .getDeclaringClass()
                .getSuperclass(), fieldName);
            }
          }
          if ((field != null) && ((fieldAlreadyChecked) || (
            (shouldUnmarshalField(field)) && 
            (this.mapper
            .shouldSerializeMember(field
            .getDeclaringClass(), fieldName)))))
          {
            String classAttribute = HierarchicalStreams.readClassAttribute(reader, this.mapper);

            if (classAttribute != null)
              type = this.mapper.realClass(classAttribute);
            else {
              type = this.mapper.defaultImplementationOf(field.getType());
            }

            Object value = unmarshallField(context, result, type, field);
            Class definedType = field.getType();
            if (!definedType.isPrimitive())
              type = definedType;
          }
          else {
            value = null;
          }
        }
      }
      else {
        implicitFieldName = implicitCollectionMapping.getFieldName();
        type = implicitCollectionMapping.getItemType();
        if (type == null) {
          String classAttribute = HierarchicalStreams.readClassAttribute(reader, this.mapper);

          type = this.mapper.realClass(classAttribute != null ? classAttribute : originalNodeName);
        }

        value = context.convertAnother(result, type);
      }

      if ((value != null) && (!type.isAssignableFrom(value.getClass())))
      {
        throw new ConversionException("Cannot convert type " + value
          .getClass().getName() + " to type " + type
          .getName());
      }

      if (field != null) {
        this.reflectionProvider.writeField(result, fieldName, value, field.getDeclaringClass());
        seenFields.add(new FastField(field.getDeclaringClass(), fieldName));
      } else if (type != null) {
        if (implicitFieldName == null)
        {
          implicitFieldName = this.mapper.getFieldNameForItemTypeAndName(context
            .getRequiredType(), value != null ? value
            .getClass() : Mapper.Null.class, originalNodeName);
        }

        if (implicitCollectionsForCurrentObject == null) {
          implicitCollectionsForCurrentObject = new HashMap();
        }
        writeValueToImplicitCollection(value, implicitCollectionsForCurrentObject, result, implicitFieldName);
      }

      reader.moveUp();
    }

    if (implicitCollectionsForCurrentObject != null) {
      Iterator iter = implicitCollectionsForCurrentObject.entrySet().iterator();
      while (iter.hasNext()) {
        Map.Entry entry = (Map.Entry)iter.next();
        Object value = entry.getValue();
        if ((value instanceof ArraysList)) {
          Object array = ((ArraysList)value).toPhysicalArray();
          this.reflectionProvider.writeField(result, (String)entry.getKey(), array, null);
        }
      }
    }

    return result;
  }

  protected Object unmarshallField(UnmarshallingContext context, Object result, Class type, Field field)
  {
    return context.convertAnother(result, type, this.mapper
      .getLocalConverter(field
      .getDeclaringClass(), field.getName()));
  }

  protected boolean shouldUnmarshalTransientFields() {
    return false;
  }

  protected boolean shouldUnmarshalField(Field field) {
    return (!Modifier.isTransient(field.getModifiers())) || (shouldUnmarshalTransientFields());
  }

  private void handleUnknownField(Class classDefiningField, String fieldName, Class resultType, String originalNodeName)
  {
    if (classDefiningField == null) {
      for (Class cls = resultType; cls != null; cls = cls.getSuperclass()) {
        if (!this.mapper.shouldSerializeMember(cls, originalNodeName)) {
          return;
        }
      }
    }
    throw new UnknownFieldException(resultType.getName(), fieldName);
  }

  private void writeValueToImplicitCollection(Object value, Map implicitCollections, Object result, String implicitFieldName) {
    Collection collection = (Collection)implicitCollections.get(implicitFieldName);
    if (collection == null) {
      Class physicalFieldType = this.reflectionProvider.getFieldType(result, implicitFieldName, null);

      if (physicalFieldType.isArray()) {
        collection = new ArraysList(physicalFieldType);
      } else {
        Class fieldType = this.mapper.defaultImplementationOf(physicalFieldType);
        if ((!Collection.class.isAssignableFrom(fieldType)) && 
          (!Map.class
          .isAssignableFrom(fieldType)))
        {
          throw new ObjectAccessException("Field " + implicitFieldName + " of " + result
            .getClass().getName() + " is configured for an implicit Collection or Map, but field is of type " + fieldType
            .getName());
        }
        if (this.pureJavaReflectionProvider == null) {
          this.pureJavaReflectionProvider = new PureJavaReflectionProvider();
        }
        Object instance = this.pureJavaReflectionProvider.newInstance(fieldType);
        if ((instance instanceof Collection)) {
          collection = (Collection)instance;
        }
        else {
          Mapper.ImplicitCollectionMapping implicitCollectionMapping = this.mapper
            .getImplicitCollectionDefForFieldName(result
            .getClass(), implicitFieldName);

          collection = new MappingList((Map)instance, implicitCollectionMapping
            .getKeyFieldName());
        }
        this.reflectionProvider.writeField(result, implicitFieldName, instance, null);
      }
      implicitCollections.put(implicitFieldName, collection);
    }
    collection.add(value);
  }

  private Class readDeclaringClass(HierarchicalStreamReader reader) {
    String attributeName = this.mapper.aliasForSystemAttribute("defined-in");
    String definedIn = attributeName == null ? null : reader.getAttribute(attributeName);
    return definedIn == null ? null : this.mapper.realClass(definedIn);
  }

  protected Object instantiateNewInstance(HierarchicalStreamReader reader, UnmarshallingContext context)
  {
    String attributeName = this.mapper.aliasForSystemAttribute("resolves-to");

    String readResolveValue = attributeName == null ? null : reader
      .getAttribute(attributeName);

    Object currentObject = context.currentObject();
    if (currentObject != null)
      return currentObject;
    if (readResolveValue != null) {
      return this.reflectionProvider.newInstance(this.mapper.realClass(readResolveValue));
    }
    return this.reflectionProvider.newInstance(context.getRequiredType());
  }

  public void flushCache()
  {
    this.serializationMethodInvoker.flushCache();
  }

  protected Object readResolve() {
    this.serializationMethodInvoker = new SerializationMethodInvoker();
    this.serializationMembers = this.serializationMethodInvoker.serializationMembers;
    return this;
  }

  private class MappingList extends AbstractList
  {
    private final Map map;
    private final String keyFieldName;
    private final Map fieldCache = new HashMap();

    public MappingList(Map map, String keyFieldName) {
      this.map = map;
      this.keyFieldName = keyFieldName;
    }

    public boolean add(Object object) {
      if (object == null) {
        boolean containsNull = !this.map.containsKey(null);
        this.map.put(null, null);
        return containsNull;
      }
      Class itemType = object.getClass();

      if (this.keyFieldName != null) {
        Field field = (Field)this.fieldCache.get(itemType);
        if (field == null) {
          field = AbstractReflectionConverter.this.reflectionProvider.getField(itemType, this.keyFieldName);
          this.fieldCache.put(itemType, field);
        }
        if (field != null)
          try {
            Object key = field.get(object);
            return this.map.put(key, object) == null;
          }
          catch (IllegalArgumentException e)
          {
            throw new ObjectAccessException("Could not get field " + field
              .getClass() + "." + field
              .getName(), e);
          }
          catch (IllegalAccessException e)
          {
            throw new ObjectAccessException("Could not get field " + field
              .getClass() + "." + field
              .getName(), e);
          }
      }
      else if ((object instanceof Map.Entry)) {
        Map.Entry entry = (Map.Entry)object;
        return this.map.put(entry.getKey(), entry.getValue()) == null;
      }

      throw new ConversionException("Element of type " + object
        .getClass().getName() + " is not defined as entry for map of type " + this.map
        .getClass().getName());
    }

    public Object get(int index) {
      throw new UnsupportedOperationException();
    }

    public int size() {
      return this.map.size();
    }
  }

  private static class ArraysList extends ArrayList
  {
    final Class physicalFieldType;

    ArraysList(Class physicalFieldType)
    {
      this.physicalFieldType = physicalFieldType;
    }

    Object toPhysicalArray() {
      Object[] objects = toArray();
      Object array = Array.newInstance(this.physicalFieldType
        .getComponentType(), objects.length);
      if (this.physicalFieldType.getComponentType().isPrimitive()) {
        for (int i = 0; i < objects.length; i++)
          Array.set(array, i, Array.get(objects, i));
      }
      else {
        System.arraycopy(objects, 0, array, 0, objects.length);
      }
      return array;
    }
  }

  private static class FieldInfo
  {
    final String fieldName;
    final Class type;
    final Class definedIn;
    final Object value;

    FieldInfo(String fieldName, Class type, Class definedIn, Object value)
    {
      this.fieldName = fieldName;
      this.type = type;
      this.definedIn = definedIn;
      this.value = value;
    }
  }

  public static class UnknownFieldException extends ConversionException
  {
    public UnknownFieldException(String type, String field)
    {
      super();
      add("field", field);
    }
  }

  public static class DuplicateFieldException extends ConversionException
  {
    public DuplicateFieldException(String msg)
    {
      super();
      add("field", msg);
    }
  }
}